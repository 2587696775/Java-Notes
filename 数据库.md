# MySQL

## 存储引擎

```sql
mysql> show engines;
```

![查看MySQL提供的所有存储引擎](F:\编程教程\个人笔记\图片\数据库\mysql-engines.png)

### MyISAM和InnoDB的区别

1.  **是否支持行级锁**：MyISAM只有表级锁，InnoDB支持行级锁和表级锁,默认是行级锁。
2.  **是否支持事务和崩溃后安全恢复**：MyISAM不支持事务，InnoDB支持。
3.  **是否支持外键**：MyISAM不支持，InnoDB支持。
4.  **是否支持MVCC**：InnoDB支持，应对高并发事务，MVCC比单纯的加锁更高效。

## 索引

### 索引失效

![索引失效的情况](F:\编程教程\个人笔记\图片\数据库\索引失效的情况.png)

## 事务

事务是逻辑上的一组操作，要么都执行，要么都不执行。

### 四大特性(ACID)

1.  原子性(Atomicty)：事务是最小的执行单位，原子性确保动作要么全部完成，要么完全不起作用；
2.  一致性(Consistency)：执行事务前后，数据保持一致；
3.  隔离性(Isolation)：多个事务访问数据库时，一个事务不被其他事务干扰，事务之间是独立的；
4.  持久性(Durability)：一个事务提交之后，它对数据库数据的改变是持久的。

### 脏读、幻读、不可重复读

#### 脏读

一个事务读取到了另一个事务未提交的数据

![img](F:\编程教程\个人笔记\图片\数据库\脏读.jpg)

#### 幻读

幻读的重点在于insert，是指一个事务两次查询得到的记录数不一样，一个事务第一次读取得到了几行数据，接着另一个事务插入了一些数据，第一个事务再次查询时发现和第一次查询结果不一样。

![img](F:\编程教程\个人笔记\图片\数据库\幻读.jpg)

#### 不可重读读

一个事务读取同一条记录2次，得到的结果不一致。比如事务A修改了数据并且提交了，此时事务B读取了，跟第一次读取到的值不一样。

![img](F:\编程教程\个人笔记\图片\数据库\不可重复读.jpg)

### 四种隔离级别

| 隔离级别         | 脏读 | 不可重复读 | 幻影读 |
| ---------------- | ---- | ---------- | ------ |
| READ-UNCOMMITTED | √    | √          | √      |
| READ-COMMITTED   | ×    | √          | √      |
| REPEATABLE-READ  | ×    | ×          | √      |
| SERIALIZABLE     | ×    | ×          | ×      |

**未提交读**(Read Uncommitted)：最低的隔离级别，允许读取尚未提交的数据变更。

**读已提交**(Read Committed)：允许读取事务已经提交的数据。

**可重复读**(Repeated Read)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。InnoDB默认的隔离级别。

**可串行化**(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

#### 隔离级别与锁的关系

##### Read Committed（读取提交内容）

在RC级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁，。

##### Repeatable Read（可重读）

## 六种约束

1.  唯一性约束(UNIQUE)
2.  主键约束(Primary Key)
3.  外键约束(Foreign Key)
4.  检查约束(CHECK)
5.  非空约束(NOT NULL)
6.  默认值约束(DEFAULT)

## 关联查询

## 一条SQL语句在MySQL中如何执行的？

### MySQL基本架构

![img](F:\编程教程\个人笔记\图片\数据库\MySQL基本架构.png)

-   **连接器**：身份认证和权限相关(登录MySQL的时候)。
-   **查询缓存**：执行查询语句时，会先查询缓存(MySQL8.0后移除，这个功能不太实用)
-   **分析器**：SQL语句经过分析器，分析SQL语句要干嘛，检查SQL语句语法是否正确
-   **优化器**：按照MySQL认为最优的方案去执行
-   **执行器**：执行语句，然后从存储引擎返回数据。

简单来说，MySQL主要分为**Server层**和**存储引擎层**

-   ==Server层==：包括上面所有组件，所有跨存储引擎的功能都在这一层实现，比如：存储过程、触发器、视图、函数等，还有一个通用的日志模块binglog。
-   ==存储引擎==：主要负责数据的存储和读取，采用可替换的插件式架构。默认存储引擎InnoDB。

#### Server层的五个组件

##### 连接器

连接器主要和身份认证和权限有关，主要负责用户登录数据库，进行认证，校验账户密码、权限。如果账户密码已通过，连接器回到权限表查询该用户的所有权限，之后在这个连接里权限判断都会依赖此时获取到的权限信息。也就是说，只要不断开连接，即使管理员修改了该用户的权限，也是不受影响的。

##### 查询缓存

-   查询缓存主要用来缓存我们所执行的select语句以及该语句的结果集。

-   MySQL会把查询语句以**key-value形式缓存在内存中**，key为SQL语句，value为结果集。

-   连接建立后，执行查询语句时，会先从查询缓存中校验这个SQL是否执行过，如果key命中了，就会直接返回结果集给客户端，如果没有命中就执行后续操作，完成后同样把结果集缓存起来。
-   查询缓存时一样会校验用户是否有该表的查询权限。

*MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。*

##### 分析器

MySQL没有命中缓存，那么就会进入分析器，主要用来分析SQL语句是来干嘛的，分为以下两步：

1.  **词法分析**：提取SQL语句中的关键字，比如select，提取出要查询的表、要查询的字段、查询条件等
2.  **语法分析**：判断SQL语句是否正确，是否符合语法

##### 优化器

优化器的作用就是把SQL语句用它认为最优的执行方案去执行，比如多个索引该如何选择索引等。经过了优化器之后可以说这个语句具体该如何执行就已经定下来。

##### 执行器

经过优化器选择了执行方案后，MySQL就开始准备执行了，会先校验用户有没有权限，没有权限返回错误信息；有权限，就会去调用存储引擎的接口返回执行的结果。

### 查询语句执行过程

**权限校验---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》存储引擎**

1.  检查用户是否有查询权限，没有权限返回错误信息
2.  先查询缓存，如果有直接返回结果
3.  没有缓存，通过分析器进行词法分析，提取关键元素：查询的表名、查询的列、查询条件；判断SQL语句是否有语法错误
4.  优化器确定SQL执行方案
5.  再次进行权限校验，校验通过调用存储引擎接口返回引擎的执行结果。

### 更新语句执行过程(新增、修改、删除)

**分析器----》权限校验----》执行器---》引擎---redo log prepare---》binlog---》redo log commit**

执行更新的时候要记录日志，MySQL自带的日志模块**binlog(归档日志)**所有的存储引擎都可以用，InnoDB还自带了一个日志模块**redolog(重做日志)**

```mysql
update tb_student A set A.age='19' where A.name=' 张三 ';
```

1.  先查询到张三这条数据，如果有缓存，会先用缓存。
2.  然后把age改成19，调用存储引擎的接口，写入这一行数据，InnoDB把数据保存在内存中，同时记录redo log，redo log进入prepare状态，然后告诉执行器执行完成随时可以提交。
3.  执行器收到通知后记录binlog，调用引擎的接口提交redo log为提交状态。
4.  更新完成