# 树

## 树的相关术语

-   **根（Root）**：树中最顶端的节点，根没有父节点。
-   **子节点（Child）**：节点所拥有子树的根节点称为该节点的子节点。
-   **父节点（Parent）**：如果节点拥有子节点，则该节点为子节点的父节点。
-   **兄弟节点（Sibling）**：与节点拥有相同父节点的节点。
-   **子孙节点（Descendant）**：节点向下路径上可达的节点。
-   **叶节点（Leaf）**：没有子节点的节点。
-   **内节点（Internal Node）**：至少有一个子节点的节点。
-   **度（Degree）**：节点拥有子树的数量。
-   **边（Edge）**：两个节点中间的链接。
-   **路径（Path）**：从节点到子孙节点过程中的边和节点所组成的序列。
-   **层级（Level）**：根为 Level 0 层，根的子节点为 Level 1 层，以此类推。
-   **高度（Height）/深度（Depth）**：树中层的数量。比如只有 Level 0,Level 1,Level 2 则高度为 3。

## 二叉树

![img](https://raw.githubusercontent.com/2587696775/Java-Notes-Pics/main/数据结构/树.jpg)

### 定义

二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)

### 特点

-   二叉树的子树有左右之分，次序不能颠倒。
-   二叉树的第i层至多有2^i-1^个结点（i≥1）
-   深度为k的二叉树至多有2^k−1^个节点（k≥1）
-   对一棵二叉树，如果叶子节点的个数为n~0~，度为2的节点个数为n~2~，则n~0~=n~2~+1

### 满二叉树

除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，如果每一个非叶子节点都存在左右子树，并且二叉树中所有的叶子节点都在同一层中，这样的二叉树称为满二叉树。

#### 满二叉树的性质

-    叶子数为2^k-1^;
-   第i层的结点数是：2^i-1^;
-   总结点数是：2^k^-1，且总节点数一定是奇数。

![img](https://raw.githubusercontent.com/2587696775/Java-Notes-Pics/main/数据结构/满二叉树和完全二叉树.png)

#### 完全二叉树

若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。

*注：完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。*

## 二叉查找树

### 定义

又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

1.  若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
2.  若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；
3.  任意节点的左、右子树也分别为二叉查找树；
4.  没有键值相等的节点。

### 性质

**对二叉查找树进行中序遍历，即可得到有序的数列。**

### 时间复杂度

它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。

**二叉查找树的高度决定了二叉查找树的查找效率。**

### 插入过程

1.  若当前的二叉查找树为空，则插入的元素为根节点；
2.  若插入的元素小于根节点值，则将元素插入到左子树中；
3.  若插入的元素不小于根节点值，则将元素插入到右子树中。